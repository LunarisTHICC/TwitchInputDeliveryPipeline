// injector_hid.cpp
// Compile with your VirtualInput SDK or source integrated.
#include <winsock2.h>
#include <windows.h>
#include <cstdint>
#include <string>
#include <vector>
#pragma comment(lib, "ws2_32.lib")

// TODO: Include/initialize VirtualInput: create virtual keyboard + mouse devices.
// Example pseudo API:
// void vi_mouse_move(int dx, int dy);
// void vi_mouse_down(uint8_t button);
// void vi_mouse_up(uint8_t button);
// void vi_mouse_wheel(int dy);
// void vi_key_down(uint16_t usage);
// void vi_key_up(uint16_t usage);

uint16_t map_code_to_usage(const std::string& code) {
  // Populate with full KeyboardEvent.code â†’ HID usage table.
  if (code == "KeyW") return 0x1A;
  if (code == "KeyA") return 0x04;
  if (code == "KeyS") return 0x16;
  if (code == "KeyD") return 0x07;
  if (code == "Space") return 0x2C;
  // ...
  return 0;
}

int main() {
  WSADATA wsa; WSAStartup(MAKEWORD(2,2), &wsa);
  SOCKET s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
  sockaddr_in addr{}; addr.sin_family=AF_INET; addr.sin_addr.s_addr=htonl(INADDR_LOOPBACK); addr.sin_port=htons(9999);
  bind(s, (sockaddr*)&addr, sizeof(addr));

  // TODO: VirtualInput device init (keyboard+mouse)

  std::vector<uint8_t> buf(1024);
  for (;;) {
    int len = recv(s, (char*)buf.data(), (int)buf.size(), 0);
    if (len < 2 || buf[0] != 1) continue;
    uint8_t t = buf[1];
    if (t == 0x01 && len >= 6) {
      int16_t dx = *(int16_t*)&buf[2];
      int16_t dy = *(int16_t*)&buf[4];
      // vi_mouse_move(dx, dy);
    } else if ((t == 0x02 || t == 0x03) && len >= 3) {
      uint8_t b = buf[2];
      // if (t==0x02) vi_mouse_down(b); else vi_mouse_up(b);
    } else if (t == 0x06 && len >= 4) {
      int16_t dy = *(int16_t*)&buf[2];
      // vi_mouse_wheel(dy);
    } else if (t == 0x04 || t == 0x05) {
      if (len < 3) continue;
      uint8_t n = buf[2]; if (3+n > len) continue;
      std::string code((char*)&buf[3], n);
      uint16_t usage = map_code_to_usage(code);
      if (usage) {
        // if (t==0x04) vi_key_down(usage); else vi_key_up(usage);
      }
    }
  }
  closesocket(s);
  WSACleanup();
  return 0;
}
